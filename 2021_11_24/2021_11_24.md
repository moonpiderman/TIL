참고링크

- [https://velog.io/@humblechoi/자료구조-면접질문-모음](https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C)

## 자료구조

### 자료구조란?

- 데이터의 편리한 접근과 조작을 가능하게 하는 데이터를 저장하거나 조직하는 방법이다.
- 문맥과 데이터의 종류에 따라 적절한 자료 구조를 사용하는 것은 전체 개발 시스템에 큰 영향을 끼친다.
- 고로, 자료구조의 다양한 종류와 각각의 장점과 한계를 잘 이해하고 상황에 맞게 올바른 자료 구조를 선택하고 사용하는 것이 중요합니다.

- 스택 Last In First Out(LIFO)
    - 엘레베이터를 기준으로 생각하면 된다. 안쪽부터 서있는다는 전제하에 나중에 들어온 사람이 문 앞에 있기 때문에 맨 앞 사람이 먼저 내린다. 즉 중간에 있는 사람이 내리기 위해서는 맨 앞에 있는 사람이 먼저 내야하는 구조가 된다.

- 큐 First In First Out (FIFO)
    - 기본적인 물류 시스템에도 적용되는 부분이다. 먼저 입고된 제품이 먼저 나가는 것. 쉽게 얘기하면 맛집에 줄 서는 것과 같다. 먼저 대기를 시작한 사람이 먼저 자리에 착석할 수 있는 것이다.

- 트리
    - 정점과 간선을 이용해서 사이클을 이루지 않도록 구성한 그래프의 한 형태이다. 계층 형태의 데이터를 표현하기에 매우 적합하다.
    - 이진탐색트리(BST) & 이진트리(Binary Tree)
        - 이진탐색트리는 이진 탐색과 연결 리스트를 결합한 자료구조이다. 이진 탐색의 효율적인 탐색 능력을 유지하면서 빈번한 자료 입력과 삭제가 가능하다는 장점이 있다. 이진 탐색 트리는 왼쪽 트리의 모든 값이 반드시 부모 노드보다 작아야하고 오른쪽은 커야한다. 시간복잡도는 트리 높이에 따른 `O(h)`
        - 이진트리는 각 노드가 자식노드를 최대한 2개까지만 가질 수 있다.

        → 차이점은 이진탐색트리의 특징인 왼쪽 트리의 모든 값이 부모 노드보다 작아야하며, 오른쪽 트리의 모든 값이 부모 노드보다 커야한다는 특징이 있다.


- 힙
    - 최댓값과 최솟값을 찾아내는 연산을 쉽게 하기 위해서 나타난 구조로. 노드의 키 값이 자식의 키 값보다 작지 않은 경우는 최대힙, 노드의 키 값이 자식의 키 값보다 크지 않은 경우는 최소힙이다.
    - 힙은 기본적으로 완전이진트리를 기반으로 한다.

- 우선순위 큐 (힙으로 구현한다)
    - 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조이다.
    - 이진트리의 높이가 하나 증가할 때마다 저장 가능한 자료의 갯수는 2배 증가하며, 비교 연산 횟수는 1회 증가한다. 즉, 삭제나 삽입 모두 최악의 경우에 O(logN)의 시간복잡도를 가진다.
    - 배열과 연결리스트로 구현시에 결국엔 나열을 해야하기 때문에 O(N)의 시간복잡도를 가진다.

- 해시 테이블
    - 해시 테이블은 key와 value로 데이터를 저장하는 자료구조이다. Key값에 해시함수를 적용해 index를 생성해서 그 index에 접근하여 저장된 데이터를 가져온다.
    - 해시 테이블은 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도를 가진다.
        - 허나, 해시의 index값이 충돌이 발생한 경우 충돌된 index 값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)의 시간복잡도를 가지게될 수도 있다.

- LinkedList와 ArrayList의 차이
    - ArrayList (스택 섹션) 여유공간 있을 때 : `O(1)` 여유공간 없을 때 : `O(N)`
        - 원하는 데이터에 순서 상관없이 접근이 가능하다.
        - 리스트 크기가 제한되어 있고, 리스트 크기를 재조정 하게되면 연산이 커진다.
        - 데이터의 추가/삭제를 위해서는 임시 배열을 생성하고 복제해야하기 때문에 시간이 오래 걸린다.

        `Array와 ArrayLList의 차이`

        - Array는 길이가 불가변이지만 ArrayList는 가변이다.

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a06b8062-f663-46ee-9c1d-c727f2214afb/Untitled.png)

    - LinkedList (힙 섹션) `O(1)`
        - 리스트의 크기에 영향 없이 데이터 추가가 가능하다.
        - 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠르다.
        - 무작위 접근이 불가하며 순차 접근만이 가능하다.

    → ArrayList의 장점이 LinkedList의 단점이 되고, ArrayList의 단점이 LinkedList의 장점이 된다.


- B-Tree 자료구조
    - 노드 내 최대 데이터 수(M)에 따라 M차 B-Tree 라고 말한다.
    - 노드의 데이터 수가 `n`개라면 자식 노드의 갯수는 `n+1`개다.
    - 노드의 데이터는 반드시 정렬된 상태여야 한다.
    - 노드의 자식노드 데이터들은 노드 데이터를 기준으로 데이터보다 작은 값은 왼쪽, 큰 값은 오른쪽에 위치한다.
    - `루트노드` 가 자식이 있다면 2개 이상의 자식을 가져한다.
    - `루트노드` 를 제외한 모든 노드는 적어도 `M/2` 개의 데이터를 갖고 있어야 한다.
        - 여기서 3차 B-Tree 까지는 1개의 데이터를 가지고 있어야하니 고려하지 않아도 되는 조건이다.
    - `탐색` 은 하향식으로 이루어진다.

## 알고리즘

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c3a3341a-0a1e-4cc9-8dd5-7412001afecb/Untitled.png)

- 버블소트
    - 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘.
    - 0번 인덱스부터 n-1번 인덱스까지 모든 인덱스를 비교하며 정렬한다.
    - 시간 복잡도는 `O(N^2)`
- 힙소트
    - 힙 자료구조로 만들어 최댓값 또는 최솟값을 꺼내어 정렬하는 알고리즘.
    - 시간 복잡도는 `O(nlogn)`
- 병합소트 merge sort
    - 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 `분할정복 알고리즘`
    - 시간 복잡도는 `O(nlogn)`
- 퀵소트
    - 분할정복 방식이다.
    - n개의 데이터를 정렬할 때 평균적으로 `O(nlogn)` 최악의 경우 `O(N^2)` 의 시간복잡도를 가진다.
    - pivot을 가지고 pivot의 앞에는 pivot보다 작은 원소들로 pivot의 뒤에는 pivot 보다 큰 원소들이 오도록 교환해줍니다.
- 삽입소트
    - 바로 옆의 데이터와 대소 비교를 한다.
    - 평균 시간 복잡도는 `O(n^2)` 이나 가장 빠른 경우 `O(n)` 까지 올라가기도 한다.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b579166-22cc-4c56-896c-67f2f3175df3/Untitled.png)

- 동적프로그래밍
    - 문제를 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 해결하는 방식이다.
    - 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어 답을 여러번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션 기법으로 속도를 향상 시킬 수 있다. (보통 파이썬의 경우 딕셔너리에 저장)
    - 조건
        - 중복되는 부분문제 (Overlapping Subproblem) : 주어진 문제는 같은 부분 문제가 여러번 재사용
        - 최적 부분구조 (Optimal Substructure) : 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구할 수 있다.
- 재귀 알고리즘
    - 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘이다.
    - 재귀 알고리즘은 반복을 중단할 조건이 반드시 필요하다.
    - 팩토리얼을 예시로 `O(n)` 의 시간복잡도를 가진다.
- DFS 깊이 우선 탐색 (Depth First Search)
    - 모든 노드를 방문하고자 하는 경우에 이 방법을 선택한다. (완전 탐색 알고리즘에 자주 이용)
    - 자기 자신을 호출하는 순환 알고리즘의 형태
    - 그래프 탐색의 경우 어떤 노드를 방문했었는지의 여부를 반드시 검사해야 한다.
    - **시간 복잡도 (정점 수 : n, 간선의 수 : e)**
        - 그래프가 인접 리스트로 표현된 경우 `O(n+e)`
        - 인접 행렬로 표현된 경우 `O(n^2)`
- BFS 너비 우선 탐색
    - 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 사용한다.
    - 시작 정점으로부터 거리가 가까운 정점의 순서로 탐색한다. (거리 1부터 2, 3 순서대로)
    - 그래프의 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다.
    - BFS는 재귀로 동작하지 않는다.
    - BFS는 방문한 노드들을 차례러 저장한 후 꺼낼 수 있는 큐 구조를 이용한다.
    - **시간 복잡도 (정점 수 : n, 간선의 수 : e)**
        - 그래프가 인접 리스트로 표현된 경우 `O(n+e)`
        - 인접 행렬로 표현된 경우 `O(n^2)`

## 기출문제

- 프로세스와 스레드
    - 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위.
    - 스레드는 할당 받은 자원을 이용하는 실행의 단위이다. 프로세스 내에 여러개 생길 수 있다.

    → 어플리케이션이 하나의 프로세스이고 그 안에서 분기처리가 스레드가 되는 셈이다.

    - 멀티 프로세스
        - 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하는 것
            - 장점: 하나의 프로세스가 잘못 되어도 프로그램은 동작
            - 단점: context switching 비용 발생
                - 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말한다.
                - Task의 대부분 정보는 register에 저장되고 PCB로 관리되고 있다.
                - 현재 실행하고 있는 task의 PCB 정보를 저장하게 된다.
                - 다음 실행할 task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행 할 수 있다.
    - 멀티 스레드
        - 프로그램을 여러개의 스레드로 구성하고 각 스레드가 작업을 하는 것
            - 장점: 시스템 자원 소모 감소, 처리 비용 감소, 스레드간 자원공유
            - 단점: 디버깅 어려움, 동기화 이슈 발생, 하나의 스레드 오류로 전체 프로세스 오류 발생 가능
- 병렬성과 동시성
    - 동시성 : 2개 이상의 task 가 있을 때 서로 다른 task 의 실행 시점에 상관 없이 task 실행이 가능

        → 멀티 태스킹을 위해 여러 개의 스레드가 번갈아가면서 실행되는 성질

        → 코틀린은 싱글스레드에서 코루틴을 사용하여 동시성을 만족할 수 있다.

    - 병렬성 : 2개 이상의 task 가 있을 때 각 task 가 물리적인 시간으로 동시에 실행이 가능

        → 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질


## [파이썬 연산자별 시간 복잡도](https://wayhome25.github.io/python/2017/06/14/time-complexity/)려
